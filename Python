import numpy as np
import sounddevice as sd
import scipy.signal as signal
import serial
import time
import matplotlib.pyplot as plt

# ===== [1. 사용자 설정] =====
PORT = 'COM5'          # 아두이노 포트
BAUD_RATE = 9600

# 물리 상수 및 컵 정보
SOUND_SPEED = 34300.0   # 소리 속도 (cm/s)
CUP_DIAMETER = 6      # 컵 지름 (cm)
TARGET_AIR_CM = 3.0     # 목표 공기 기둥 높이 (3cm)

# [핵심 수정] 정밀도 대폭 상향
# 기존 3~5회 -> 10회 연속 감지 시에만 정지 (오작동/조기차단 완전 방지)
STOP_TRIGGER_COUNT = 13

# 주파수 탐색 범위
FREQ_MIN_LIMIT = 200     
FREQ_MAX_LIMIT = 3500    

# [초기 잡음 방지]
SPLASH_GUARD_TIME = 3.0  
SPLASH_CEILING = 1000    

# 시스템 설정
IGNORE_DURATION = 1.0       
CALIBRATION_DURATION = 2.0  
SAMPLE_RATE = 44100
CHUNK_SIZE = 4096           

# 데이터 기록용
history_time = [] 
history_freq = [] 

# 상태 변수
freq_buffer = []
full_audio_buffer = []
is_filling = False
filling_start_time = 0
calibration_done = False
target_freq = 0

# 제어용 변수
last_tracked_freq = 0       
consecutive_loss_count = 0 
consecutive_stop_hits = 0   # 목표 도달 카운트

# 아두이노 연결
ser = None
try:
    ser = serial.Serial(PORT, BAUD_RATE, timeout=0.1)
    time.sleep(2)
    ser.reset_input_buffer()
    print(f"[{PORT}] 아두이노 연결 성공.")
except:
    print("아두이노 연결 실패 (테스트 모드)")

# ===== [2. 스마트 주파수 추적 (알고리즘 유지)] =====
def get_smart_frequency(chunk, rate, last_freq, current_ceiling):
    # 1. 필터링
    sos = signal.butter(4, 200, 'hp', fs=rate, output='sos')
    filtered_chunk = signal.sosfilt(sos, chunk)
    
    # 2. FFT
    windowed = filtered_chunk * np.hamming(len(chunk))
    fft_val = np.abs(np.fft.rfft(windowed))
    freqs = np.fft.rfftfreq(len(chunk), d=1/rate)
    
    # 3. 범위 제한
    mask = (freqs >= FREQ_MIN_LIMIT) & (freqs <= current_ceiling)
    valid_freqs = freqs[mask]
    valid_mag = fft_val[mask]
    
    if len(valid_mag) == 0: return 0

    # 4. 피크 찾기
    peaks, _ = signal.find_peaks(valid_mag, prominence=np.max(valid_mag)*0.15, distance=20)
    
    if len(peaks) == 0: return 0

    peak_freqs = valid_freqs[peaks]
    peak_mags = valid_mag[peaks]

    # 추적 로직 (연속성 + 기본음 우선)
    if last_freq > 0:
        lower_bound = last_freq - 50
        upper_bound = last_freq + 400
        
        candidates_mask = (peak_freqs >= lower_bound) & (peak_freqs <= upper_bound)
        cand_freqs = peak_freqs[candidates_mask]
        cand_mags = peak_mags[candidates_mask]

        if len(cand_freqs) > 0:
            return cand_freqs[np.argmax(cand_mags)]
        else:
            return 0 
    else:
        strong_mask = peak_mags > (np.max(peak_mags) * 0.5)
        strong_freqs = peak_freqs[strong_mask]
        if len(strong_freqs) > 0:
            return np.min(strong_freqs)
        else:
            return peak_freqs[np.argmax(peak_mags)]

# ===== [3. 오디오 처리 및 제어] =====
def audio_callback(indata, frames, time_info, status):
    global is_filling, filling_start_time, calibration_done, target_freq
    global freq_buffer, full_audio_buffer
    global history_time, history_freq
    global last_tracked_freq, consecutive_loss_count, consecutive_stop_hits
    
    if not is_filling: return

    chunk = indata.flatten().astype(float)
    full_audio_buffer.append(chunk)

    if np.max(np.abs(chunk)) < 0.01: return

    try:
        elapsed = time.time() - filling_start_time
        
        if elapsed < SPLASH_GUARD_TIME:
            current_ceil = SPLASH_CEILING 
        else:
            current_ceil = FREQ_MAX_LIMIT

        detected_f = get_smart_frequency(chunk, SAMPLE_RATE, last_tracked_freq, current_ceil)
        
        if detected_f == 0:
            consecutive_loss_count += 1
            if consecutive_loss_count > 10: last_tracked_freq = 0
            return
        
        consecutive_loss_count = 0
        last_tracked_freq = detected_f

        freq_buffer.append(detected_f)
        if len(freq_buffer) > 5: freq_buffer.pop(0)
        stable_f = np.median(freq_buffer)
        
        history_time.append(elapsed)
        history_freq.append(detected_f)

        # 현재 공기 기둥 높이 역산
        current_air_height = (SOUND_SPEED / (4 * stable_f)) - (0.3 * CUP_DIAMETER)

        # --- 제어 로직 ---
        if elapsed < IGNORE_DURATION:
            print(f"[대기] 안정화 중... {stable_f:.0f}Hz", end='\r')
            last_tracked_freq = stable_f
            
        elif elapsed < (IGNORE_DURATION + CALIBRATION_DURATION):
            print(f"[측정] 초기 높이 계산 중: {current_air_height:.1f} cm ({stable_f:.0f}Hz)", end='\r')
            
        elif not calibration_done:
            target_L_effective = TARGET_AIR_CM + (0.3 * CUP_DIAMETER)
            target_freq = SOUND_SPEED / (4 * target_L_effective)
            calibration_done = True
            
            print(f"\n===== [설정 완료] =====")
            print(f" - 초기 공기 높이 : {current_air_height:.1f} cm")
            print(f" - 목표 주파수   : {target_freq:.0f} Hz (남은공간 3cm)")
            print(f" - 정지 조건     : 목표치 {STOP_TRIGGER_COUNT}회 연속 감지 시")
            print(f"=======================")
            
        else:
            # [핵심] 10회 연속 도달 체크
            if stable_f >= target_freq:
                consecutive_stop_hits += 1
            else:
                consecutive_stop_hits = 0 # 한 번이라도 떨어지면 리셋 (아주 엄격하게)

            # 상태바 출력 (카운트 상태 표시)
            # 진행률을 시각적으로 보여줌: [#####-----]
            progress_bar = "#" * consecutive_stop_hits + "-" * (STOP_TRIGGER_COUNT - consecutive_stop_hits)
            
            status_msg = f"[주입 중] {stable_f:.0f}Hz ({current_air_height:.1f}cm) | 확신도: [{progress_bar}]"
            print(status_msg, end='\r')

            # 정지 명령
            if consecutive_stop_hits >= STOP_TRIGGER_COUNT:
                print(f"\n\n[완료] 목표 높이 정확히 도달! ({stable_f:.0f}Hz 유지됨)")
                print(">>> 밸브 잠금 (STOP)")
                if ser: ser.write(b'0')
                is_filling = False
                plot_result()

    except Exception as e:
        print(f"Error: {e}")

# ===== [4. 결과 그래프] =====
def plot_result():
    if not history_time:
        print("데이터 없음")
        return
    plt.figure(figsize=(10, 6))
    plt.scatter(history_time, history_freq, c='blue', alpha=0.5, s=15, label='Detected Freq')
    if target_freq > 0:
        plt.axhline(y=target_freq, color='r', linestyle='--', label=f'Target ({target_freq:.0f}Hz)')
    plt.axvline(x=SPLASH_GUARD_TIME, color='green', linestyle=':', label='Splash Guard End')
    plt.title("High-Precision Water Level Control")
    plt.xlabel("Time (s)")
    plt.ylabel("Frequency (Hz)")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()

# ===== [5. 메인 루프] =====
try:
    with sd.InputStream(callback=audio_callback, channels=1, samplerate=SAMPLE_RATE, blocksize=CHUNK_SIZE):
        print("\n[준비] 아두이노 ON 버튼을 누르면 시작됩니다.")
        while True:
            if ser and ser.in_waiting:
                msg = ser.readline().decode().strip()
                if "ON" in msg:
                    is_filling = True
                    filling_start_time = time.time()
                    calibration_done = False
                    freq_buffer = []
                    full_audio_buffer = []
                    history_time = [] 
                    history_freq = [] 
                    last_tracked_freq = 0
                    consecutive_stop_hits = 0
                    print("\n>>> 물 주입 시작!")
                elif "OFF" in msg:
                    if is_filling:
                        is_filling = False
                        plot_result()
            time.sleep(0.01)
except KeyboardInterrupt:
    if ser:
        ser.write(b'0')
        ser.close()
    plot_result()
