import numpy as np                                              # 수치 계산용
import sounddevice as sd                                         # 실시간 마이크 입력
import scipy.signal as signal                                    # 필터/피크탐지
import serial                                                    # 아두이노 시리얼 통신(pyserial)
import time                                                      # 시간 처리
import threading                                                 # 백그라운드 스레드
import matplotlib                                                # matplotlib 본체

# ===== customtkinter (카페 키오스크 UI) =====
# 설치: pip install customtkinter pillow matplotlib               # pillow도 필요(이미지)
import customtkinter as ctk                                      # modern tkinter
from PIL import Image                                            # 이미지 로드(Pillow)

# ===== matplotlib GUI 임베딩(TkAgg) =====
from matplotlib.figure import Figure                             # GUI용 Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg   # Tk에 그래프 넣기

# ===== [1. 사용자 설정] =====
PORT = 'COM17'                                                   # 아두이노 포트
BAUD_RATE = 9600                                                 # 보드레이트

SOUND_SPEED = 34300.0                                            # 소리 속도 (cm/s)

FLOW_RATE = 21.0                                                 # 펌프 유량 (mL/s)
END_CORRECTION_K = 0.4                                           # 관구 보정 계수

TARGET_AIR_CM = 3.0                                              # 목표 공기 기둥 높이 (cm)

STOP_TRIGGER_COUNT = 15                                          # 정지 확신 카운트

FREQ_MIN_LIMIT = 200                                             # 주파수 탐색 하한
FREQ_MAX_LIMIT = 3500                                            # 주파수 탐색 상한

SPLASH_GUARD_TIME = 2.0                                          # 초기 튐 가드 시간(s)
CONTROL_START_TIME = 6.0                                         # 제어 시작 시간(s)

SAMPLE_RATE = 44100                                              # 샘플레이트
CHUNK_SIZE = 4096                                                # 콜백 블록 크기

# ===== [로고 설정] =====
LOGO_PATH = r"C:/Users/user/OneDrive/바탕 화면/동의대/팀플/캡스톤디자인/캡스톤디자인 I/정수기 음원/DEU.png"
LOGO_SIZE = (75, 75)

# ===== [창 위치/크기 고정 설정] =====
WIN_W = 720                                                      # 창 가로(px)
WIN_H = 900                                                      # 창 세로(px)
WIN_X = 80                                                       # 좌상단 x(px)
WIN_Y = 40                                                       # 좌상단 y(px)
USE_CENTER = False                                               # True=중앙, False=고정

# ===== [그래프 설정] =====
PLOT_UPDATE_MS = 200                                             # 그래프 갱신 주기(ms)
PLOT_MAX_POINTS = 2000                                           # 너무 많으면 느려서 제한(최근 N개만)

# ===== [2. 데이터/상태 변수] =====
history_time = []                                                # 기록 시간
history_freq = []                                                # 기록 주파수

reg_time_buffer = []                                             # 회귀용 시간 버퍼
reg_inv_freq_buffer = []                                         # 회귀용 1/f 버퍼

freq_buffer = []                                                 # 주파수 안정화 버퍼
is_filling = False                                               # 주입 중 여부
filling_start_time = 0.0                                         # 주입 시작 시간
calibration_done = False                                         # 최소 데이터 확보 여부

target_freq = 0.0                                                # 목표 주파수
current_diameter = 0.0                                           # 추정 지름(cm)
last_tracked_freq = 0.0                                          # 마지막 추적 주파수
consecutive_loss_count = 0                                       # 추적 실패 카운트
consecutive_stop_hits = 0                                        # 정지 확신 카운트

request_plot = False                                             # (이제 GUI 내 실시간이므로 거의 불필요)
last_stable_f = 0.0                                              # UI 표시용 안정 주파수
last_current_air = 0.0                                           # UI 표시용 공기층(cm)

ser = None                                                       # 시리얼 객체
audio_stream = None                                              # 오디오 스트림 객체

lock = threading.Lock()                                          # 스레드 공유 보호용 락

# ===== [터미널 출력 제어] =====
last_print_time = 0.0
PRINT_INTERVAL = 0.10

# ===== [3. 시리얼 연결] =====
def connect_serial(port: str, baud: int) -> bool:
    global ser
    try:
        ser = serial.Serial(port, baud, timeout=0.1)
        time.sleep(2)
        ser.reset_input_buffer()
        print(f"[{port}] 아두이노 연결 성공.")
        return True
    except Exception:
        ser = None
        print(f"[{port}] 아두이노 연결 실패 (테스트 모드).")
        return False

def serial_write(b: bytes) -> None:
    if ser is None:
        return
    try:
        ser.write(b)
    except Exception:
        return

# ===== [4. 시작/정지 상태 초기화] =====
def start_filling_local() -> None:
    global is_filling, filling_start_time
    global calibration_done, freq_buffer
    global reg_time_buffer, reg_inv_freq_buffer
    global history_time, history_freq
    global last_tracked_freq, consecutive_stop_hits
    global consecutive_loss_count
    global current_diameter, target_freq
    global request_plot, last_stable_f, last_current_air
    global last_print_time

    with lock:
        is_filling = True
        filling_start_time = time.time()

        calibration_done = False
        freq_buffer = []
        reg_time_buffer = []
        reg_inv_freq_buffer = []

        history_time = []
        history_freq = []

        last_tracked_freq = 0.0
        consecutive_loss_count = 0
        consecutive_stop_hits = 0

        current_diameter = 0.0
        target_freq = 0.0

        request_plot = False
        last_stable_f = 0.0
        last_current_air = 0.0

        last_print_time = 0.0

    print("\n>>> 물 주입 시작! (실시간 너비 보정 모드)")

def stop_filling_local(plot_after: bool) -> None:
    global is_filling, request_plot
    with lock:
        is_filling = False
        if plot_after:
            request_plot = True
    print("\n>>> 물 주입 종료.")

# ===== [5. 스마트 주파수 추적] =====
def get_smart_frequency(chunk, rate, last_freq, current_ceiling):
    sos = signal.butter(4, 200, 'hp', fs=rate, output='sos')
    filtered_chunk = signal.sosfilt(sos, chunk)

    windowed = filtered_chunk * np.hamming(len(chunk))
    fft_val = np.abs(np.fft.rfft(windowed))
    freqs = np.fft.rfftfreq(len(chunk), d=1/rate)

    mask = (freqs >= FREQ_MIN_LIMIT) & (freqs <= current_ceiling)
    valid_freqs = freqs[mask]
    valid_mag = fft_val[mask]

    if len(valid_mag) == 0:
        return 0

    peaks, _ = signal.find_peaks(
        valid_mag,
        prominence=np.max(valid_mag) * 0.15,
        distance=20
    )
    if len(peaks) == 0:
        return 0

    peak_freqs = valid_freqs[peaks]
    peak_mags = valid_mag[peaks]

    if last_freq > 0:
        lower_bound = last_freq - 50
        upper_bound = last_freq + 400
        candidates_mask = (peak_freqs >= lower_bound) & (peak_freqs <= upper_bound)
        cand_freqs = peak_freqs[candidates_mask]
        cand_mags = peak_mags[candidates_mask]
        if len(cand_freqs) > 0:
            return float(cand_freqs[np.argmax(cand_mags)])
        return 0
    else:
        strong_mask = peak_mags > (np.max(peak_mags) * 0.5)
        strong_freqs = peak_freqs[strong_mask]
        if len(strong_freqs) > 0:
            return float(np.min(strong_freqs))
        return float(peak_freqs[np.argmax(peak_mags)])

# ===== [7. 오디오 콜백] =====
def audio_callback(indata, frames, time_info, status):
    global is_filling, filling_start_time, calibration_done
    global target_freq, current_diameter
    global freq_buffer, reg_time_buffer, reg_inv_freq_buffer
    global history_time, history_freq
    global last_tracked_freq, consecutive_loss_count, consecutive_stop_hits
    global request_plot, last_stable_f, last_current_air
    global last_print_time

    with lock:
        if not is_filling:
            return

    chunk = indata.flatten().astype(float)
    if np.max(np.abs(chunk)) < 0.01:
        return

    try:
        with lock:
            elapsed = time.time() - filling_start_time

        current_ceil = 1000 if elapsed < SPLASH_GUARD_TIME else FREQ_MAX_LIMIT

        detected_f = get_smart_frequency(chunk, SAMPLE_RATE, last_tracked_freq, current_ceil)
        if detected_f == 0:
            consecutive_loss_count += 1
            if consecutive_loss_count > 10:
                last_tracked_freq = 0.0
            return

        consecutive_loss_count = 0
        last_tracked_freq = detected_f

        freq_buffer.append(detected_f)
        if len(freq_buffer) > 5:
            freq_buffer.pop(0)
        stable_f = float(np.median(freq_buffer))

        with lock:
            history_time.append(elapsed)
            history_freq.append(detected_f)
            last_stable_f = stable_f

        if elapsed > SPLASH_GUARD_TIME:
            reg_time_buffer.append(elapsed)
            reg_inv_freq_buffer.append(1.0 / stable_f)

            if len(reg_time_buffer) > 10:
                s_a, _ = np.polyfit(reg_time_buffer, reg_inv_freq_buffer, 1)
                abs_a = abs(float(s_a))
                if abs_a > 1e-9:
                    temp_D = np.sqrt((16 * FLOW_RATE) / (np.pi * SOUND_SPEED * abs_a))
                    if 1.0 < temp_D < 20.0:
                        if current_diameter == 0.0:
                            current_diameter = float(temp_D)
                        else:
                            current_diameter = (current_diameter * 0.95) + (float(temp_D) * 0.05)

                        target_L_effective = TARGET_AIR_CM + (END_CORRECTION_K * current_diameter)
                        target_freq = SOUND_SPEED / (4 * target_L_effective)
                        calibration_done = True

        now = time.time()
        if elapsed > CONTROL_START_TIME and calibration_done:
            current_air = (SOUND_SPEED / (4 * stable_f)) - (END_CORRECTION_K * current_diameter)
            with lock:
                last_current_air = float(current_air)

            if stable_f >= target_freq:
                consecutive_stop_hits += 1
            else:
                if consecutive_stop_hits > 0:
                    consecutive_stop_hits -= 1

            if (now - last_print_time) >= PRINT_INTERVAL:
                bar_len = min(consecutive_stop_hits, STOP_TRIGGER_COUNT)
                progress_bar = "#" * bar_len + "-" * (STOP_TRIGGER_COUNT - bar_len)
                print(
                    f"[제어] D:{current_diameter:.2f}cm | {stable_f:.0f}Hz / {target_freq:.0f}Hz | 공기:{current_air:.2f}cm | 확신:[{progress_bar}]",
                    end='\r'
                )
                last_print_time = now

            if consecutive_stop_hits >= STOP_TRIGGER_COUNT:
                print("\n\n[완료] 목표 도달! 밸브 잠금.")
                print(f"최종 계산된 너비: {current_diameter:.4f} cm")
                serial_write(b'0')
                with lock:
                    is_filling = False
                return

        elif elapsed <= CONTROL_START_TIME and calibration_done:
            if (now - last_print_time) >= PRINT_INTERVAL:
                print(f"[보정 중] D:{current_diameter:.2f}cm (데이터: {len(reg_time_buffer)}개)", end='\r')
                last_print_time = now

    except Exception:
        return

# ===== [8. 오디오 스트림 시작] =====
def ensure_audio_stream():
    global audio_stream
    if audio_stream is not None:
        return
    audio_stream = sd.InputStream(
        callback=audio_callback,
        channels=1,
        samplerate=SAMPLE_RATE,
        blocksize=CHUNK_SIZE
    )
    audio_stream.start()

# ===== [9. 시리얼 수신 스레드] =====
def serial_reader_loop(on_status):
    global ser
    while True:
        if ser is None:
            time.sleep(0.1)
            continue
        try:
            if ser.in_waiting:
                msg = ser.readline().decode(errors='ignore').strip()
                if "ON" in msg:
                    start_filling_local()
                    on_status("아두이노 ON 수신 → 주입 시작")
                elif "OFF" in msg:
                    stop_filling_local(plot_after=True)
                    on_status("아두이노 OFF 수신 → 주입 종료")
        except Exception:
            pass
        time.sleep(0.01)

# ===== [10. customtkinter GUI (카페 키오스크 느낌)] =====
def run_kiosk_gui():
    ctk.set_appearance_mode("light")
    ctk.set_default_color_theme("blue")

    C_BG = "#F6F7FB"
    C_CARD = "#FFFFFF"
    C_NAVY = "#0B2D5B"
    C_NAVY_HOVER = "#123A73"
    C_TEXT = "#0F172A"
    C_MUTED = "#64748B"

    app = ctk.CTk()
    app.title("주파수 기반 급수 제어 시스템")
    app.configure(fg_color=C_BG)

    # ===== 창 크기 + 위치 고정 =====
    app.update_idletasks()
    if USE_CENTER:
        sw = app.winfo_screenwidth()
        sh = app.winfo_screenheight()
        x = max(0, (sw - WIN_W) // 2)
        y = max(0, (sh - WIN_H) // 2)
        app.geometry(f"{WIN_W}x{WIN_H}+{x}+{y}")
    else:
        app.geometry(f"{WIN_W}x{WIN_H}+{WIN_X}+{WIN_Y}")
    app.minsize(WIN_W, WIN_H)

    status_var = ctk.StringVar(value="초기화 중...")
    port_var = ctk.StringVar(value=PORT)
    baud_var = ctk.StringVar(value=str(BAUD_RATE))

    d_var = ctk.StringVar(value="지름(D) : - cm")
    f_var = ctk.StringVar(value="주파수(F) : - Hz")
    tf_var = ctk.StringVar(value="목표(Target) : - Hz")
    air_var = ctk.StringVar(value="공기층(Air) : - cm")
    hit_var = ctk.StringVar(value=f"확신(Hits) : 0/{STOP_TRIGGER_COUNT}")

    def set_status(s: str):
        status_var.set(s)
        print(f"\n[GUI] {s}")

    def do_connect():
        global PORT, BAUD_RATE
        PORT = port_entry.get().strip()
        try:
            BAUD_RATE = int(baud_entry.get().strip())
        except Exception:
            BAUD_RATE = 9600
        ok = connect_serial(PORT, BAUD_RATE)
        set_status("아두이노 연결 성공" if ok else "아두이노 연결 실패(테스트 모드)")
        ensure_audio_stream()
        print("\n[준비] 아두이노 ON/OFF 대기중...")
        print(f"[설정] 유량: {FLOW_RATE} mL/s | 동적 보정 모드")

    def gui_on():
        serial_write(b'1')
        start_filling_local()
        set_status("GUI ON → 주입 시작")

    def gui_off():
        serial_write(b'0')
        stop_filling_local(plot_after=True)
        set_status("GUI OFF → 주입 종료")

    def on_close():
        serial_write(b'0')
        try:
            if ser is not None:
                ser.close()
        except Exception:
            pass
        try:
            if audio_stream is not None:
                audio_stream.stop()
                audio_stream.close()
        except Exception:
            pass
        app.destroy()

    # ===== 레이아웃 =====
    container = ctk.CTkFrame(app, fg_color=C_BG, corner_radius=0)
    container.pack(fill="both", expand=True, padx=30, pady=30)

    card = ctk.CTkFrame(container, fg_color=C_CARD, corner_radius=20)
    card.pack(fill="both", expand=True, padx=0, pady=0)

    header = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=20)
    header.pack(fill="x", padx=28, pady=(28, 12))

    title = ctk.CTkLabel(
        header, text="주파수 기반 급수 제어 시스템", text_color=C_NAVY,
        font=ctk.CTkFont(family="Malgun Gothic", size=30, weight="bold")
    )
    title.pack(anchor="w")

    subtitle = ctk.CTkLabel(
        header, text="ON/OFF + 실시간 추정값 + 실시간 그래프",
        text_color=C_MUTED,
        font=ctk.CTkFont(family="Malgun Gothic", size=14, weight="normal")
    )
    subtitle.pack(anchor="w", pady=(6, 0))

    # ===== 로고(우측 상단) =====
    try:
        pil_img = Image.open(LOGO_PATH)
        logo_img = ctk.CTkImage(light_image=pil_img, size=LOGO_SIZE)
        app.logo_img = logo_img                                   # GC 방지
        logo_label = ctk.CTkLabel(header, text="", image=logo_img, fg_color="transparent")
        logo_label.place(relx=1.0, rely=0.0, anchor="ne")
    except Exception as e:
        print(f"\n[로고] 로드 실패: {e}")

    # ===== 연결 영역 =====
    conn = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=16)
    conn.pack(fill="x", padx=28, pady=(6, 14))

    conn.grid_columnconfigure(0, weight=0)
    conn.grid_columnconfigure(1, weight=1)
    conn.grid_columnconfigure(2, weight=0)
    conn.grid_columnconfigure(3, weight=1)

    ctk.CTkLabel(
        conn, text="포트(PORT)", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=14, weight="bold")
    ).grid(row=0, column=0, sticky="w", padx=(0, 12), pady=(0, 10))

    port_entry = ctk.CTkEntry(
        conn, textvariable=port_var, height=40,
        fg_color="#F1F5F9", border_color="#E2E8F0", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=14)
    )
    port_entry.grid(row=0, column=1, sticky="ew", pady=(0, 10))

    ctk.CTkLabel(
        conn, text="보드레이트(BAUD)", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=14, weight="bold")
    ).grid(row=0, column=2, sticky="w", padx=(18, 12), pady=(0, 10))

    baud_entry = ctk.CTkEntry(
        conn, textvariable=baud_var, height=40,
        fg_color="#F1F5F9", border_color="#E2E8F0", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=14)
    )
    baud_entry.grid(row=0, column=3, sticky="ew", pady=(0, 10))

    connect_btn = ctk.CTkButton(
        conn, text="연결", height=46,
        fg_color=C_CARD, hover_color="#EEF2FF",
        border_color="#CBD5E1", border_width=2,
        text_color=C_NAVY,
        font=ctk.CTkFont(family="Malgun Gothic", size=16, weight="bold"),
        command=do_connect
    )
    connect_btn.grid(row=1, column=0, columnspan=4, sticky="ew")

    # ===== 버튼 =====
    btn_area = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=16)
    btn_area.pack(fill="x", padx=28, pady=(4, 14))

    on_btn = ctk.CTkButton(
        btn_area, text="ON  (주입 시작)", height=64,
        fg_color=C_NAVY, hover_color=C_NAVY_HOVER,
        text_color="white",
        font=ctk.CTkFont(family="Malgun Gothic", size=20, weight="bold"),
        corner_radius=18,
        command=gui_on
    )
    on_btn.pack(fill="x", pady=(0, 10))

    off_btn = ctk.CTkButton(
        btn_area, text="OFF (주입 종료)", height=64,
        fg_color=C_CARD, hover_color="#F1F5F9",
        border_color="#CBD5E1", border_width=2,
        text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=20, weight="bold"),
        corner_radius=18,
        command=gui_off
    )
    off_btn.pack(fill="x")

    # ===== 진행바 =====
    progress_area = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=16)
    progress_area.pack(fill="x", padx=28, pady=(0, 12))

    progress_title = ctk.CTkLabel(
        progress_area, text="정지 확신도", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=16, weight="bold")
    )
    progress_title.pack(anchor="w", pady=(0, 8))

    progress = ctk.CTkProgressBar(
        progress_area, height=18, corner_radius=10,
        fg_color="#E5E7EB", progress_color=C_NAVY
    )
    progress.set(0.0)
    progress.pack(fill="x")

    # ===== 실시간 값 =====
    stats = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=16)
    stats.pack(fill="x", padx=28, pady=(0, 12))

    def make_stat_row(parent, var):
        row = ctk.CTkFrame(parent, fg_color=C_CARD, corner_radius=12)
        row.pack(fill="x", pady=4)
        lbl = ctk.CTkLabel(
            row, textvariable=var, text_color=C_TEXT,
            font=ctk.CTkFont(family="Malgun Gothic", size=16, weight="bold")
        )
        lbl.pack(anchor="w", padx=6)
        return row

    make_stat_row(stats, d_var)
    make_stat_row(stats, f_var)
    make_stat_row(stats, tf_var)
    make_stat_row(stats, air_var)
    make_stat_row(stats, hit_var)

    # ===== 그래프 영역(GUI 내 임베딩) =====
    plot_frame = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=16)
    plot_frame.pack(fill="both", expand=True, padx=28, pady=(0, 12))

    plot_title = ctk.CTkLabel(
        plot_frame, text="실시간 주파수 추적 그래프", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=16, weight="bold")
    )
    plot_title.pack(anchor="w", pady=(0, 6))

    fig = Figure(figsize=(6, 3), dpi=100)                      # Figure(plt.figure 대신)
    ax = fig.add_subplot(111)                                     # 축 생성
    ax.set_xlabel("t [s]")
    ax.set_ylabel("f [Hz]")
    ax.grid(True, alpha=0.3)

    fig.tight_layout(pad=3.0)          

    line_freq, = ax.plot([], [], linewidth=1.5)                   # 주파수 라인
    target_line = ax.axhline(y=0, linestyle="--", alpha=0.8)       # 목표선(나중에 위치 갱신)

    canvas = FigureCanvasTkAgg(fig, master=plot_frame)            # Tk에 캔버스 생성
    canvas_widget = canvas.get_tk_widget()                        # 위젯 가져오기
    canvas_widget.pack(fill="both", expand=True)                  # 프레임에 꽉 채우기

    def update_plot():
        with lock:
            t_list = list(history_time)
            f_list = list(history_freq)
            tf = float(target_freq)

        if len(t_list) == 0:
            line_freq.set_data([], [])
            target_line.set_ydata([0, 0])
            ax.set_xlim(0, 1)
            ax.set_ylim(FREQ_MIN_LIMIT, FREQ_MAX_LIMIT)
            canvas.draw_idle()
            return

        # 최근 N개만 표시(성능)
        if len(t_list) > PLOT_MAX_POINTS:
            t_list = t_list[-PLOT_MAX_POINTS:]
            f_list = f_list[-PLOT_MAX_POINTS:]

        line_freq.set_data(t_list, f_list)                        # 라인 데이터 갱신

        # x/y 범위 자동 조정
        t_max = max(t_list)
        ax.set_xlim(max(0, t_max - 30), max(5, t_max))            # 최근 30초 윈도우(원하면 변경)
        f_min = min(f_list)
        f_max = max(f_list)
        pad = max(50, 0.1 * (f_max - f_min))                      # 여백
        ax.set_ylim(max(0, f_min - pad), f_max + pad)

        # 목표선 갱신
        if tf > 0:
            target_line.set_ydata([tf, tf])
            target_line.set_alpha(0.9)
        else:
            target_line.set_ydata([0, 0])
            target_line.set_alpha(0.0)

        canvas.draw_idle()                                        # 부드럽게 갱신

    # ===== 하단 상태바 =====
    footer = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=20)
    footer.pack(fill="x", padx=28, pady=(0, 22))

    status_lbl = ctk.CTkLabel(
        footer, textvariable=status_var, text_color=C_MUTED,
        font=ctk.CTkFont(family="Malgun Gothic", size=14, weight="normal")
    )
    status_lbl.pack(anchor="w")

    def periodic_update():
        with lock:
            d = current_diameter
            sf = last_stable_f
            tf = target_freq
            air = last_current_air
            hits = consecutive_stop_hits

        d_var.set(f"지름(D) : {d:.2f} cm" if d > 0 else "지름(D) : - cm")
        f_var.set(f"주파수(F) : {sf:.0f} Hz" if sf > 0 else "주파수(F) : - Hz")
        tf_var.set(f"목표(Target) : {tf:.0f} Hz" if tf > 0 else "목표(Target) : - Hz")
        air_var.set(f"공기층(Air) : {air:.2f} cm" if air != 0 else "공기층(Air) : - cm")
        hit_var.set(f"확신(Hits) : {hits}/{STOP_TRIGGER_COUNT}")

        progress.set(hits / float(STOP_TRIGGER_COUNT))

        update_plot()                                             # GUI 내 그래프 실시간 갱신
        app.after(PLOT_UPDATE_MS, periodic_update)

    app.protocol("WM_DELETE_WINDOW", on_close)
    app.bind("<Escape>", lambda e: on_close())

    do_connect()
    ensure_audio_stream()

    t = threading.Thread(target=serial_reader_loop, args=(set_status,), daemon=True)
    t.start()

    periodic_update()
    app.mainloop()

if __name__ == "__main__":
    run_kiosk_gui()
