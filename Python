import numpy as np                                              # 수치 계산용
import sounddevice as sd                                         # 실시간 마이크 입력
import scipy.signal as signal                                    # 필터/피크탐지
import serial                                                    # 아두이노 시리얼 통신(pyserial)
import time                                                      # 시간 처리
import threading                                                 # 백그라운드 스레드
import tkinter as tk                                             # GUI
from tkinter import ttk                                          # GUI 위젯
import matplotlib.pyplot as plt                                  # 결과 그래프

# ===== [1. 사용자 설정] =====
PORT = 'COM17'                                                   # 아두이노 포트
BAUD_RATE = 9600                                                 # 보드레이트

SOUND_SPEED = 34300.0                                            # 소리 속도 (cm/s)

FLOW_RATE = 21.0                                                 # 펌프 유량 (mL/s)
END_CORRECTION_K = 0.4                                           # 관구 보정 계수

TARGET_AIR_CM = 3.0                                              # 목표 공기 기둥 높이 (cm)

STOP_TRIGGER_COUNT = 15                                          # 정지 확신 카운트

FREQ_MIN_LIMIT = 200                                             # 주파수 탐색 하한
FREQ_MAX_LIMIT = 3500                                            # 주파수 탐색 상한

SPLASH_GUARD_TIME = 2.0                                          # 초기 튐 가드 시간(s)
CONTROL_START_TIME = 6.0                                         # 제어 시작 시간(s)

SAMPLE_RATE = 44100                                              # 샘플레이트
CHUNK_SIZE = 4096                                                # 콜백 블록 크기

# ===== [2. 데이터/상태 변수] =====
history_time = []                                                # 기록 시간
history_freq = []                                                # 기록 주파수

reg_time_buffer = []                                             # 회귀용 시간 버퍼
reg_inv_freq_buffer = []                                         # 회귀용 1/f 버퍼

freq_buffer = []                                                 # 주파수 안정화 버퍼
is_filling = False                                               # 주입 중 여부
filling_start_time = 0.0                                         # 주입 시작 시간
calibration_done = False                                         # 최소 데이터 확보 여부

target_freq = 0.0                                                # 목표 주파수
current_diameter = 0.0                                           # 추정 지름(cm)
last_tracked_freq = 0.0                                          # 마지막 추적 주파수
consecutive_loss_count = 0                                       # 추적 실패 카운트
consecutive_stop_hits = 0                                        # 정지 확신 카운트

request_plot = False                                             # 그래프 요청 플래그(콜백->메인/GUI)
last_stable_f = 0.0                                              # UI 표시용 안정 주파수
last_current_air = 0.0                                           # UI 표시용 공기층(cm)

ser = None                                                       # 시리얼 객체
audio_stream = None                                              # 오디오 스트림 객체

lock = threading.Lock()                                          # 스레드 공유 보호용 락

# ===== [터미널 출력 제어] =====
last_print_time = 0.0                                            # (추가) 마지막 터미널 출력 시각
PRINT_INTERVAL = 0.10                                             # (추가) 0.1초마다 한 번만 출력

# ===== [3. 시리얼 연결] =====
def connect_serial(port: str, baud: int) -> bool:                # 시리얼 연결 함수
    global ser                                                   # 전역 시리얼 객체 사용
    try:                                                         # 예외 처리 시작
        ser = serial.Serial(port, baud, timeout=0.1)             # 포트 오픈
        time.sleep(2)                                            # 아두이노 리셋 대기
        ser.reset_input_buffer()                                 # 입력 버퍼 초기화
        print(f"[{port}] 아두이노 연결 성공.")                    # (추가) 터미널 출력
        return True                                              # 성공 반환
    except Exception:                                            # 실패 시
        ser = None                                               # 테스트 모드
        print(f"[{port}] 아두이노 연결 실패 (테스트 모드).")       # (추가) 터미널 출력
        return False                                             # 실패 반환

def serial_write(b: bytes) -> None:                              # 안전 전송
    if ser is None:                                              # 시리얼 없으면 종료
        return                                                   # 리턴
    try:                                                         # 예외 처리
        ser.write(b)                                             # 바이트 전송
    except Exception:                                            # 전송 실패
        return                                                   # 무시

# ===== [4. 시작/정지 상태 초기화] =====
def start_filling_local() -> None:                               # 주입 시작(로컬)
    global is_filling, filling_start_time                        # 전역 사용
    global calibration_done, freq_buffer                          # 전역 사용
    global reg_time_buffer, reg_inv_freq_buffer                    # 전역 사용
    global history_time, history_freq                              # 전역 사용
    global last_tracked_freq, consecutive_stop_hits                # 전역 사용
    global consecutive_loss_count                                  # 전역 사용
    global current_diameter, target_freq                           # 전역 사용
    global request_plot, last_stable_f, last_current_air           # 전역 사용
    global last_print_time                                         # (추가) 출력 타이머

    with lock:                                                   # 락으로 보호
        is_filling = True                                        # 주입 상태 ON
        filling_start_time = time.time()                         # 시작 시각 기록

        calibration_done = False                                 # 보정 상태 초기화
        freq_buffer = []                                         # 안정화 버퍼 초기화
        reg_time_buffer = []                                     # 회귀 시간 초기화
        reg_inv_freq_buffer = []                                 # 회귀 1/f 초기화

        history_time = []                                        # 기록 초기화
        history_freq = []                                        # 기록 초기화

        last_tracked_freq = 0.0                                  # 추적 초기화
        consecutive_loss_count = 0                                # 실패 카운트 초기화
        consecutive_stop_hits = 0                                 # 정지 확신 초기화

        current_diameter = 0.0                                   # 지름 초기화
        target_freq = 0.0                                        # 목표 주파수 초기화

        request_plot = False                                     # 그래프 요청 초기화
        last_stable_f = 0.0                                      # UI값 초기화
        last_current_air = 0.0                                   # UI값 초기화

        last_print_time = 0.0                                    # (추가) 출력 타이머 초기화

    print("\n>>> 물 주입 시작! (실시간 너비 보정 모드)")           # (추가) 터미널 출력

def stop_filling_local(plot_after: bool) -> None:                # 주입 종료(로컬)
    global is_filling, request_plot                               # 전역 사용
    with lock:                                                   # 락
        is_filling = False                                       # 주입 OFF
        if plot_after:                                           # 그래프 띄울지
            request_plot = True                                  # 요청 플래그 ON
    print("\n>>> 물 주입 종료.")                                   # (추가) 터미널 출력

# ===== [5. 스마트 주파수 추적] =====
def get_smart_frequency(chunk, rate, last_freq, current_ceiling): # 주파수 추적 함수
    sos = signal.butter(4, 200, 'hp', fs=rate, output='sos')      # 200Hz HPF 설계
    filtered_chunk = signal.sosfilt(sos, chunk)                  # 필터 적용

    windowed = filtered_chunk * np.hamming(len(chunk))           # 해밍 윈도잉
    fft_val = np.abs(np.fft.rfft(windowed))                      # FFT 크기값
    freqs = np.fft.rfftfreq(len(chunk), d=1/rate)                # 주파수 축

    mask = (freqs >= FREQ_MIN_LIMIT) & (freqs <= current_ceiling)# 관심 대역 마스크
    valid_freqs = freqs[mask]                                    # 유효 주파수
    valid_mag = fft_val[mask]                                    # 유효 스펙트럼

    if len(valid_mag) == 0:                                      # 데이터 없으면
        return 0                                                 # 0 반환

    peaks, _ = signal.find_peaks(                                # 피크 탐색
        valid_mag,                                                # 스펙트럼
        prominence=np.max(valid_mag) * 0.15,                      # 최소 prominence
        distance=20                                               # 피크 간격
    )

    if len(peaks) == 0:                                          # 피크 없으면
        return 0                                                 # 0 반환

    peak_freqs = valid_freqs[peaks]                              # 피크 주파수들
    peak_mags = valid_mag[peaks]                                 # 피크 크기들

    if last_freq > 0:                                            # 추적 중이면
        lower_bound = last_freq - 50                             # 하한
        upper_bound = last_freq + 400                            # 상한
        candidates_mask = (peak_freqs >= lower_bound) & (peak_freqs <= upper_bound)
        cand_freqs = peak_freqs[candidates_mask]                 # 후보 주파수
        cand_mags = peak_mags[candidates_mask]                   # 후보 크기

        if len(cand_freqs) > 0:                                  # 후보 있으면
            return float(cand_freqs[np.argmax(cand_mags)])        # 가장 강한 후보
        return 0                                                 # 후보 없으면 0
    else:                                                        # 초기 탐색이면
        strong_mask = peak_mags > (np.max(peak_mags) * 0.5)       # 강한 피크 마스크
        strong_freqs = peak_freqs[strong_mask]                   # 강한 주파수들
        if len(strong_freqs) > 0:                                # 강한 피크 있으면
            return float(np.min(strong_freqs))                    # 가장 낮은 강피크
        return float(peak_freqs[np.argmax(peak_mags)])            # 최강 피크

# ===== [6. 결과 그래프] =====
def plot_result():                                               # 결과 플롯 함수
    global history_time, history_freq                             # 전역 사용
    global target_freq, current_diameter                          # 전역 사용
    if not history_time:                                          # 기록 없으면
        return                                                    # 종료
    plt.figure(figsize=(10, 6))                                   # 그림 생성
    plt.scatter(history_time, history_freq, alpha=0.5, s=15, label='Detected Freq')  # 산점도
    if target_freq > 0:                                           # 목표 주파수 있으면
        plt.axhline(y=target_freq, linestyle='--', label=f'Target ({target_freq:.0f}Hz)')  # 목표선
    plt.title(f"결과 (유량:{FLOW_RATE} mL/s, 최종 D:{current_diameter:.2f} cm)")      # (한글)
    plt.xlabel("시간 (s)")                                        # (한글)
    plt.ylabel("주파수 (Hz)")                                     # (한글)
    plt.legend()                                                  # 범례
    plt.grid(True, alpha=0.3)                                     # 그리드
    plt.show()                                                    # 표시

# ===== [7. 오디오 콜백] =====
def audio_callback(indata, frames, time_info, status):            # 오디오 콜백
    global is_filling, filling_start_time, calibration_done        # 전역
    global target_freq, current_diameter                           # 전역
    global freq_buffer, reg_time_buffer, reg_inv_freq_buffer       # 전역
    global history_time, history_freq                               # 전역
    global last_tracked_freq, consecutive_loss_count, consecutive_stop_hits  # 전역
    global request_plot, last_stable_f, last_current_air           # 전역
    global last_print_time                                         # (추가) 출력 타이머

    with lock:                                                    # 락
        if not is_filling:                                        # 주입 아니면
            return                                                # 바로 리턴

    chunk = indata.flatten().astype(float)                         # 1채널 배열
    if np.max(np.abs(chunk)) < 0.01:                               # 신호 너무 작으면
        return                                                    # 무시

    try:                                                          # 예외 시작
        with lock:                                                # 락
            elapsed = time.time() - filling_start_time             # 경과시간

        if elapsed < SPLASH_GUARD_TIME:                            # 초반이면
            current_ceil = 1000                                    # 천장 낮게
        else:                                                      # 이후면
            current_ceil = FREQ_MAX_LIMIT                          # 상한 사용

        detected_f = get_smart_frequency(chunk, SAMPLE_RATE, last_tracked_freq, current_ceil)  # 추적
        if detected_f == 0:                                        # 추적 실패면
            consecutive_loss_count += 1                             # 실패 증가
            if consecutive_loss_count > 10:                        # 많이 실패하면
                last_tracked_freq = 0.0                            # 추적 리셋
            return                                                 # 리턴

        consecutive_loss_count = 0                                 # 실패 리셋
        last_tracked_freq = detected_f                             # 추적 갱신

        freq_buffer.append(detected_f)                             # 버퍼에 추가
        if len(freq_buffer) > 5:                                   # 5개 넘으면
            freq_buffer.pop(0)                                     # 앞 제거
        stable_f = float(np.median(freq_buffer))                   # 중앙값 안정화

        with lock:                                                 # 락
            history_time.append(elapsed)                            # 기록 시간
            history_freq.append(detected_f)                         # 기록 주파수
            last_stable_f = stable_f                                # UI 업데이트

        # ---- [데이터 수집 & 실시간 너비 보정] ----
        if elapsed > SPLASH_GUARD_TIME:                             # 2초 이후부터
            reg_time_buffer.append(elapsed)                         # 회귀 시간
            reg_inv_freq_buffer.append(1.0 / stable_f)              # 회귀 1/f

            if len(reg_time_buffer) > 10:                           # 데이터 10개 이상
                s_a, _ = np.polyfit(reg_time_buffer, reg_inv_freq_buffer, 1)  # 1차 회귀
                abs_a = abs(float(s_a))                             # 기울기 절댓값

                if abs_a > 1e-9:                                    # 0 방지
                    temp_D = np.sqrt((16 * FLOW_RATE) / (np.pi * SOUND_SPEED * abs_a))  # D 계산

                    if 1.0 < temp_D < 20.0:                         # 이상치 필터
                        if current_diameter == 0.0:                 # 최초면
                            current_diameter = float(temp_D)        # 바로 대입
                        else:                                       # 이후면
                            current_diameter = (current_diameter * 0.95) + (float(temp_D) * 0.05)  # 누적평균

                        target_L_effective = TARGET_AIR_CM + (END_CORRECTION_K * current_diameter)  # 유효 길이
                        target_freq = SOUND_SPEED / (4 * target_L_effective)  # 목표 주파수
                        calibration_done = True                      # 제어 가능

        # ---- [제어 로직] ----
        now = time.time()                                           # (추가) 현재 시각
        if elapsed > CONTROL_START_TIME and calibration_done:        # 제어 시작 조건
            current_air = (SOUND_SPEED / (4 * stable_f)) - (END_CORRECTION_K * current_diameter)  # 공기층
            with lock:                                               # 락
                last_current_air = float(current_air)                # UI 업데이트

            if stable_f >= target_freq:                              # 목표 이상이면
                consecutive_stop_hits += 1                           # 확신 증가
            else:                                                    # 아니면
                if consecutive_stop_hits > 0:                        # 0보다 크면
                    consecutive_stop_hits -= 1                       # 감소

            # (추가) 터미널 출력: 원래와 같은 스타일(제어 줄)
            if (now - last_print_time) >= PRINT_INTERVAL:            # 출력 주기 제한
                bar_len = min(consecutive_stop_hits, STOP_TRIGGER_COUNT)   # 바 길이
                progress_bar = "#" * bar_len + "-" * (STOP_TRIGGER_COUNT - bar_len)  # 바 문자열
                print(
                    f"[제어] D:{current_diameter:.2f}cm | {stable_f:.0f}Hz / {target_freq:.0f}Hz | 공기:{current_air:.2f}cm | 확신:[{progress_bar}]",
                    end='\r'
                )
                last_print_time = now                                 # 마지막 출력 갱신

            if consecutive_stop_hits >= STOP_TRIGGER_COUNT:            # 확신 충분하면
                print("\n\n[완료] 목표 도달! 밸브 잠금.")              # (추가) 완료 메시지
                print(f"최종 계산된 너비: {current_diameter:.4f} cm")  # (추가) 최종 D
                serial_write(b'0')                                     # 아두이노 OFF 전송
                with lock:                                             # 락
                    is_filling = False                                 # 주입 종료
                    request_plot = True                                # 그래프 요청
                return                                                  # 콜백 종료

        elif elapsed <= CONTROL_START_TIME and calibration_done:        # 보정 후 제어 대기구간
            # (추가) 터미널 출력: 원래와 같은 스타일(보정 중)
            if (now - last_print_time) >= PRINT_INTERVAL:              # 출력 주기 제한
                print(f"[보정 중] D:{current_diameter:.2f}cm (데이터: {len(reg_time_buffer)}개)", end='\r')
                last_print_time = now                                   # 마지막 출력 갱신

    except Exception:                                                  # 예외 발생 시
        return                                                        # 조용히 무시

# ===== [8. 오디오 스트림 시작] =====
def ensure_audio_stream():                                            # 스트림 보장
    global audio_stream                                               # 전역 사용
    if audio_stream is not None:                                      # 이미 있으면
        return                                                        # 종료
    audio_stream = sd.InputStream(                                    # 입력 스트림 생성
        callback=audio_callback,                                      # 콜백 지정
        channels=1,                                                   # 1채널
        samplerate=SAMPLE_RATE,                                       # 샘플레이트
        blocksize=CHUNK_SIZE                                          # 블록크기
    )
    audio_stream.start()                                              # 스트림 시작

# ===== [9. 시리얼 수신 스레드] =====
def serial_reader_loop(on_status):                                    # 시리얼 읽기 루프
    global ser                                                        # 전역 시리얼
    while True:                                                       # 무한 루프
        if ser is None:                                               # 미연결이면
            time.sleep(0.1)                                           # 대기
            continue                                                  # 계속
        try:                                                          # 예외 시작
            if ser.in_waiting:                                        # 수신 있으면
                msg = ser.readline().decode(errors='ignore').strip()  # 한 줄 읽기
                if "ON" in msg:                                       # ON 수신이면
                    start_filling_local()                              # 로컬 시작
                    on_status("ON 수신: 주입 시작")                    # 상태 표시
                elif "OFF" in msg:                                     # OFF 수신이면
                    stop_filling_local(plot_after=True)                # 로컬 정지+그래프
                    on_status("OFF 수신: 주입 종료")                   # 상태 표시
        except Exception:                                              # 예외 시
            pass                                                       # 무시
        time.sleep(0.01)                                              # 짧게 쉬기

# ===== [10. GUI] =====
def run_gui():                                                        # GUI 실행
    root = tk.Tk()                                                    # 루트 생성
    root.title("급수 제어 GUI")                                       # 타이틀

    status_var = tk.StringVar(value="초기화 중...")                   # 상태 텍스트
    port_var = tk.StringVar(value=PORT)                               # 포트 입력
    baud_var = tk.StringVar(value=str(BAUD_RATE))                     # 보드레이트 입력

    d_var = tk.StringVar(value="지름(D): - cm")                       # (한글) 지름 표시
    f_var = tk.StringVar(value="주파수(F): - Hz")                     # (한글) 주파수 표시
    tf_var = tk.StringVar(value="목표(Target): - Hz")                 # (한글) 목표 표시
    air_var = tk.StringVar(value="공기층(Air): - cm")                 # (한글) 공기층 표시
    hit_var = tk.StringVar(value="확신(Hits): 0")                     # (한글) 확신 표시

    def set_status(s: str):                                           # 상태 변경
        status_var.set(s)                                             # 텍스트 반영

    def do_connect():                                                 # 연결 버튼
        global PORT, BAUD_RATE                                        # 전역 갱신
        PORT = port_var.get().strip()                                 # 포트 읽기
        try:                                                          # 변환 예외
            BAUD_RATE = int(baud_var.get().strip())                   # baud 읽기
        except Exception:                                             # 실패 시
            BAUD_RATE = 9600                                          # 기본값
        ok = connect_serial(PORT, BAUD_RATE)                          # 연결 시도
        set_status("아두이노 연결 성공" if ok else "아두이노 연결 실패(테스트 모드)")  # 상태
        ensure_audio_stream()                                         # 오디오 스트림 시작/유지
        print("\n[준비] 아두이노 ON/OFF 대기중...")                   # (추가) 터미널 안내
        print(f"[설정] 유량: {FLOW_RATE} mL/s | 동적 보정 모드")       # (추가) 터미널 안내

    def gui_on():                                                     # GUI ON
        serial_write(b'1')                                            # 아두이노 ON 전송
        start_filling_local()                                         # 로컬 시작(에코 없어도 동작)
        set_status("GUI ON: 주입 시작")                               # 상태

    def gui_off():                                                    # GUI OFF
        serial_write(b'0')                                            # 아두이노 OFF 전송
        stop_filling_local(plot_after=True)                           # 로컬 정지+그래프
        set_status("GUI OFF: 주입 종료")                              # 상태

    def periodic_update():                                            # 주기 갱신
        global request_plot                                           # 전역 사용
        with lock:                                                    # 락
            d = current_diameter                                      # 지름 복사
            sf = last_stable_f                                        # 안정 주파수 복사
            tf = target_freq                                          # 목표 주파수 복사
            air = last_current_air                                    # 공기층 복사
            hits = consecutive_stop_hits                              # 히트 복사
            plot_now = request_plot                                   # 플래그 복사
            if request_plot:                                          # 요청 있으면
                request_plot = False                                  # 플래그 해제

        if d > 0:
            d_var.set(f"지름(D): {d:.2f} cm")
        else:
            d_var.set("지름(D): - cm")

        if sf > 0:
            f_var.set(f"주파수(F): {sf:.0f} Hz")
        else:
            f_var.set("주파수(F): - Hz")

        if tf > 0:
            tf_var.set(f"목표(Target): {tf:.0f} Hz")
        else:
            tf_var.set("목표(Target): - Hz")

        if air != 0:
            air_var.set(f"공기층(Air): {air:.2f} cm")
        else:
            air_var.set("공기층(Air): - cm")

        hit_var.set(f"확신(Hits): {hits}/{STOP_TRIGGER_COUNT}")

        if plot_now:                                                  # 그래프 요청이면
            set_status("종료: 결과 그래프 표시")                        # 상태
            plot_result()                                             # 메인 스레드에서 표시

        root.after(100, periodic_update)                              # 100ms마다 반복

    def on_close():                                                   # 창 닫기
        serial_write(b'0')                                            # 종료 시 OFF
        try:
            if ser is not None:
                ser.close()
        except Exception:
            pass
        try:
            if audio_stream is not None:
                audio_stream.stop()
                audio_stream.close()
        except Exception:
            pass
        root.destroy()

    # ---- UI 레이아웃 ----
    frm = ttk.Frame(root, padding=12)
    frm.grid(row=0, column=0, sticky="nsew")

    ttk.Label(frm, text="포트(PORT)").grid(row=0, column=0, sticky="w")
    ttk.Entry(frm, textvariable=port_var, width=12).grid(row=0, column=1, sticky="w")
    ttk.Label(frm, text="보드레이트(BAUD)").grid(row=0, column=2, sticky="w")
    ttk.Entry(frm, textvariable=baud_var, width=10).grid(row=0, column=3, sticky="w")
    ttk.Button(frm, text="연결", command=do_connect).grid(row=0, column=4, padx=6)

    ttk.Button(frm, text="ON (주입 시작)", command=gui_on).grid(row=1, column=0, columnspan=5, sticky="ew", pady=6)
    ttk.Button(frm, text="OFF (주입 종료)", command=gui_off).grid(row=2, column=0, columnspan=5, sticky="ew")

    ttk.Label(frm, textvariable=d_var).grid(row=3, column=0, columnspan=5, sticky="w", pady=(10, 0))
    ttk.Label(frm, textvariable=f_var).grid(row=4, column=0, columnspan=5, sticky="w")
    ttk.Label(frm, textvariable=tf_var).grid(row=5, column=0, columnspan=5, sticky="w")
    ttk.Label(frm, textvariable=air_var).grid(row=6, column=0, columnspan=5, sticky="w")
    ttk.Label(frm, textvariable=hit_var).grid(row=7, column=0, columnspan=5, sticky="w")

    ttk.Label(frm, textvariable=status_var).grid(row=8, column=0, columnspan=5, sticky="w", pady=(10, 0))

    root.protocol("WM_DELETE_WINDOW", on_close)

    do_connect()
    ensure_audio_stream()

    t = threading.Thread(target=serial_reader_loop, args=(set_status,), daemon=True)
    t.start()

    periodic_update()
    root.mainloop()

# ===== [11. 엔트리포인트] =====
if __name__ == "__main__":
    run_gui()
