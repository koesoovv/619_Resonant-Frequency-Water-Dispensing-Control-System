import numpy as np                                              # 수치 계산용
import sounddevice as sd                                         # 실시간 마이크 입력
import scipy.signal as signal                                    # 필터/피크탐지
import serial                                                    # 아두이노 시리얼 통신(pyserial)
import time                                                      # 시간 처리
import threading                                                 # 백그라운드 스레드
import matplotlib                                                # matplotlib 본체

# ===== customtkinter (카페 키오스크 UI) =====
# 설치: pip install customtkinter pillow matplotlib               # pillow도 필요(이미지)
import customtkinter as ctk                                      # modern tkinter
from PIL import Image                                            # 이미지 로드(Pillow)

# ===== matplotlib GUI 임베딩(TkAgg) =====
from matplotlib.figure import Figure                             # GUI용 Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg   # Tk에 그래프 넣기

# =========================================================
# [1. 사용자 설정]
# =========================================================
PORT = 'COM17'                                                   # 아두이노 포트
BAUD_RATE = 9600                                                 # 보드레이트

SOUND_SPEED = 34300.0                                            # 소리 속도 (cm/s)

FLOW_RATE = 21.0                                                 # 펌프 유량 (mL/s)
END_CORRECTION_K = 0.4                                           # 관구 보정 계수

TARGET_AIR_CM = 3.0                                              # 목표 공기 기둥 높이 (cm)

STOP_TRIGGER_COUNT = 15                                          # 정지 확신 카운트

FREQ_MIN_LIMIT = 200                                             # 주파수 탐색 하한
FREQ_MAX_LIMIT = 3500                                            # 주파수 탐색 상한

SPLASH_GUARD_TIME = 2.0                                          # 초기 튐 가드 시간(s)
CONTROL_START_TIME = 6.0                                         # 제어 시작 시간(s)

SAMPLE_RATE = 44100                                              # 샘플레이트
CHUNK_SIZE = 4096                                                # 콜백 블록 크기

# ===== [로고 설정] =====
LOGO_PATH = r"C:/Users/user/OneDrive/바탕 화면/동의대/팀플/캡스톤디자인/캡스톤디자인 I/정수기 음원/DEU.png"  # 로고 경로
LOGO_SIZE = (75, 75)                                             # 로고 크기(px)

# ===== [창 위치/크기 고정 설정 - 가로 디스플레이용] =====
WIN_W = 1000                                                     # 창 가로(px) - RPi 800x480이면 800
WIN_H = 600                                                      # 창 세로(px) - RPi 800x480이면 480
WIN_X = 80                                                       # 좌상단 x(px)
WIN_Y = 40                                                       # 좌상단 y(px)
USE_CENTER = False                                               # True=중앙, False=고정

# ===== [그래프 설정] =====
PLOT_UPDATE_MS = 200                                             # 그래프 갱신 주기(ms)
PLOT_MAX_POINTS = 2000                                           # 최근 N개만 표시(성능)

# =========================================================
# [2. 데이터/상태 변수]
# =========================================================
history_time = []                                                # 기록 시간
history_freq = []                                                # 기록 주파수

reg_time_buffer = []                                             # 회귀용 시간 버퍼
reg_inv_freq_buffer = []                                         # 회귀용 1/f 버퍼

freq_buffer = []                                                 # 주파수 안정화 버퍼
is_filling = False                                               # 주입 중 여부
filling_start_time = 0.0                                         # 주입 시작 시간
calibration_done = False                                         # 최소 데이터 확보 여부

target_freq = 0.0                                                # 목표 주파수
current_diameter = 0.0                                           # 추정 지름(cm)
last_tracked_freq = 0.0                                          # 마지막 추적 주파수
consecutive_loss_count = 0                                       # 추적 실패 카운트
consecutive_stop_hits = 0                                        # 정지 확신 카운트

last_stable_f = 0.0                                              # UI 표시용 안정 주파수
last_current_air = 0.0                                           # UI 표시용 공기층(cm)

ser = None                                                       # 시리얼 객체
audio_stream = None                                              # 오디오 스트림 객체

lock = threading.Lock()                                          # 스레드 공유 보호용 락

# ===== [터미널 출력 제어] =====
last_print_time = 0.0
PRINT_INTERVAL = 0.10


# =========================================================
# [3. 시리얼 연결]
# =========================================================
def connect_serial(port: str, baud: int) -> bool:                # 시리얼 연결 함수
    global ser                                                   # 전역 시리얼 객체 사용
    try:                                                         # 예외 처리 시작
        ser = serial.Serial(port, baud, timeout=0.1)             # 포트 오픈
        time.sleep(2)                                            # 아두이노 리셋 대기
        ser.reset_input_buffer()                                 # 입력 버퍼 초기화
        print(f"[{port}] 아두이노 연결 성공.")                    # 터미널 출력
        return True                                              # 성공 반환
    except Exception:                                            # 실패 시
        ser = None                                               # 테스트 모드
        print(f"[{port}] 아두이노 연결 실패 (테스트 모드).")       # 터미널 출력
        return False                                             # 실패 반환


def serial_write(b: bytes) -> None:                              # 안전 전송 함수
    if ser is None:                                              # 시리얼 없으면
        return                                                   # 종료
    try:                                                         # 예외 처리
        ser.write(b)                                             # 전송
    except Exception:                                            # 실패 시
        return                                                   # 무시


# =========================================================
# [4. 시작/정지 상태 초기화]
# =========================================================
def start_filling_local() -> None:                               # 주입 시작(로컬)
    global is_filling, filling_start_time                        # 상태
    global calibration_done, freq_buffer                          # 버퍼
    global reg_time_buffer, reg_inv_freq_buffer                    # 회귀
    global history_time, history_freq                              # 기록
    global last_tracked_freq, consecutive_stop_hits                # 추적
    global consecutive_loss_count                                  # 실패
    global current_diameter, target_freq                           # 추정
    global last_stable_f, last_current_air                         # UI
    global last_print_time                                         # 출력 타이머

    with lock:                                                   # 락
        is_filling = True                                        # 주입 ON
        filling_start_time = time.time()                         # 시작시간

        calibration_done = False                                 # 보정 초기화
        freq_buffer = []                                         # 안정화 초기화
        reg_time_buffer = []                                     # 회귀 초기화
        reg_inv_freq_buffer = []                                 # 회귀 초기화

        history_time = []                                        # 기록 초기화
        history_freq = []                                        # 기록 초기화

        last_tracked_freq = 0.0                                  # 추적 초기화
        consecutive_loss_count = 0                                # 실패 초기화
        consecutive_stop_hits = 0                                 # 확신 초기화

        current_diameter = 0.0                                   # 지름 초기화
        target_freq = 0.0                                        # 목표 초기화

        last_stable_f = 0.0                                      # UI 초기화
        last_current_air = 0.0                                   # UI 초기화

        last_print_time = 0.0                                    # 터미널 출력 타이머 초기화

    print("\n>>> 물 주입 시작! (실시간 너비 보정 모드)")            # 터미널 출력


def stop_filling_local() -> None:                                # 주입 종료(로컬)
    global is_filling                                             # 상태
    with lock:                                                   # 락
        is_filling = False                                       # 주입 OFF
    print("\n>>> 물 주입 종료.")                                   # 터미널 출력


# =========================================================
# [5. 스마트 주파수 추적]
# =========================================================
def get_smart_frequency(chunk, rate, last_freq, current_ceiling): # 주파수 추적 함수
    sos = signal.butter(4, 200, 'hp', fs=rate, output='sos')      # 200Hz HPF
    filtered_chunk = signal.sosfilt(sos, chunk)                  # 필터 적용

    windowed = filtered_chunk * np.hamming(len(chunk))           # 해밍 윈도
    fft_val = np.abs(np.fft.rfft(windowed))                      # FFT 크기
    freqs = np.fft.rfftfreq(len(chunk), d=1/rate)                # 주파수 축

    mask = (freqs >= FREQ_MIN_LIMIT) & (freqs <= current_ceiling)# 관심 대역
    valid_freqs = freqs[mask]                                    # 유효 주파수
    valid_mag = fft_val[mask]                                    # 유효 크기

    if len(valid_mag) == 0:                                      # 비었으면
        return 0                                                 # 실패

    peaks, _ = signal.find_peaks(                                # 피크 탐지
        valid_mag,                                               # 크기 배열
        prominence=np.max(valid_mag) * 0.15,                     # prominence 기준
        distance=20                                              # 피크 간 최소 간격
    )
    if len(peaks) == 0:                                          # 피크 없으면
        return 0                                                 # 실패

    peak_freqs = valid_freqs[peaks]                              # 피크 주파수
    peak_mags = valid_mag[peaks]                                 # 피크 크기

    if last_freq > 0:                                            # 이전 주파수 있으면
        lower_bound = last_freq - 50                             # 아래 경계
        upper_bound = last_freq + 400                            # 위 경계
        candidates_mask = (peak_freqs >= lower_bound) & (peak_freqs <= upper_bound)  # 후보
        cand_freqs = peak_freqs[candidates_mask]                 # 후보 주파수
        cand_mags = peak_mags[candidates_mask]                   # 후보 크기
        if len(cand_freqs) > 0:                                  # 후보 있으면
            return float(cand_freqs[np.argmax(cand_mags)])        # 가장 큰 후보 반환
        return 0                                                 # 없으면 실패
    else:                                                        # 초기 상태면
        strong_mask = peak_mags > (np.max(peak_mags) * 0.5)       # 강한 피크
        strong_freqs = peak_freqs[strong_mask]                   # 강한 피크 주파수
        if len(strong_freqs) > 0:                                # 있으면
            return float(np.min(strong_freqs))                    # 가장 낮은 강피크
        return float(peak_freqs[np.argmax(peak_mags)])            # 아니면 최대 피크


# =========================================================
# [6. 오디오 콜백]
# =========================================================
def audio_callback(indata, frames, time_info, status):           # 사운드디바이스 콜백
    global is_filling, filling_start_time, calibration_done       # 상태
    global target_freq, current_diameter                          # 추정치
    global freq_buffer, reg_time_buffer, reg_inv_freq_buffer      # 버퍼
    global history_time, history_freq                             # 기록
    global last_tracked_freq, consecutive_loss_count, consecutive_stop_hits  # 추적
    global last_stable_f, last_current_air                         # UI 표시
    global last_print_time                                        # 출력 제어

    with lock:                                                   # 락
        if not is_filling:                                       # 주입 중 아니면
            return                                               # 종료

    chunk = indata.flatten().astype(float)                       # 1채널 배열
    if np.max(np.abs(chunk)) < 0.01:                             # 너무 작으면(무음)
        return                                                   # 종료

    try:
        with lock:
            elapsed = time.time() - filling_start_time           # 경과시간(s)

        current_ceil = 1000 if elapsed < SPLASH_GUARD_TIME else FREQ_MAX_LIMIT  # 초기 천장

        detected_f = get_smart_frequency(chunk, SAMPLE_RATE, last_tracked_freq, current_ceil)  # 주파수
        if detected_f == 0:                                      # 실패면
            consecutive_loss_count += 1                          # 실패 증가
            if consecutive_loss_count > 10:                      # 너무 많으면
                last_tracked_freq = 0.0                          # 리셋
            return                                               # 종료

        consecutive_loss_count = 0                               # 실패 리셋
        last_tracked_freq = detected_f                            # 마지막 추적 갱신

        freq_buffer.append(detected_f)                            # 안정화 버퍼 추가
        if len(freq_buffer) > 5:                                  # 길면
            freq_buffer.pop(0)                                    # 앞 제거
        stable_f = float(np.median(freq_buffer))                  # 안정 주파수(중앙값)

        with lock:
            history_time.append(elapsed)                          # 시간 기록
            history_freq.append(detected_f)                       # 주파수 기록
            last_stable_f = stable_f                              # UI 표시값 갱신

        if elapsed > SPLASH_GUARD_TIME:                           # 튐 이후부터
            reg_time_buffer.append(elapsed)                       # 회귀 시간
            reg_inv_freq_buffer.append(1.0 / stable_f)            # 1/f

            if len(reg_time_buffer) > 10:                         # 데이터 충분하면
                s_a, _ = np.polyfit(reg_time_buffer, reg_inv_freq_buffer, 1)  # 1차 회귀
                abs_a = abs(float(s_a))                           # 기울기 절댓값
                if abs_a > 1e-9:                                  # 0 방지
                    temp_D = np.sqrt((16 * FLOW_RATE) / (np.pi * SOUND_SPEED * abs_a))  # 지름 추정
                    if 1.0 < temp_D < 20.0:                       # 합리 범위
                        if current_diameter == 0.0:               # 초기면
                            current_diameter = float(temp_D)      # 바로 설정
                        else:                                     # 아니면
                            current_diameter = (current_diameter * 0.95) + (float(temp_D) * 0.05)  # EMA

                        target_L_effective = TARGET_AIR_CM + (END_CORRECTION_K * current_diameter)  # 유효 길이
                        target_freq = SOUND_SPEED / (4 * target_L_effective)  # 목표 주파수
                        calibration_done = True                   # 보정 완료

        now = time.time()                                         # 현재시간
        if elapsed > CONTROL_START_TIME and calibration_done:      # 제어 시작 조건
            current_air = (SOUND_SPEED / (4 * stable_f)) - (END_CORRECTION_K * current_diameter)  # 공기층
            with lock:
                last_current_air = float(current_air)             # UI 표시값 갱신

            if stable_f >= target_freq:                           # 목표 도달 방향이면
                consecutive_stop_hits += 1                        # 확신 증가
            else:                                                 # 아니면
                if consecutive_stop_hits > 0:                     # 0 아래 방지
                    consecutive_stop_hits -= 1                    # 확신 감소

            if (now - last_print_time) >= PRINT_INTERVAL:         # 터미널 출력 주기
                bar_len = min(consecutive_stop_hits, STOP_TRIGGER_COUNT)  # 진행바 길이
                progress_bar = "#" * bar_len + "-" * (STOP_TRIGGER_COUNT - bar_len)  # 문자열
                print(
                    f"[제어] D:{current_diameter:.2f}cm | {stable_f:.0f}Hz / {target_freq:.0f}Hz | 공기:{current_air:.2f}cm | 확신:[{progress_bar}]",
                    end='\r'
                )
                last_print_time = now                             # 출력 시각 갱신

            if consecutive_stop_hits >= STOP_TRIGGER_COUNT:       # 확신 충분하면
                print("\n\n[완료] 목표 도달! 밸브 잠금.")
                print(f"최종 계산된 너비: {current_diameter:.4f} cm")
                serial_write(b'0')                                # 아두이노 OFF
                with lock:
                    is_filling = False                            # 주입 종료
                return

        elif elapsed <= CONTROL_START_TIME and calibration_done:   # 보정중 표시
            if (now - last_print_time) >= PRINT_INTERVAL:
                print(f"[보정 중] D:{current_diameter:.2f}cm (데이터: {len(reg_time_buffer)}개)", end='\r')
                last_print_time = now

    except Exception:
        return


# =========================================================
# [7. 오디오 스트림 시작]
# =========================================================
def ensure_audio_stream():                                       # 스트림 생성 보장
    global audio_stream                                          # 전역 스트림
    if audio_stream is not None:                                 # 이미 있으면
        return                                                   # 종료
    audio_stream = sd.InputStream(                               # 입력 스트림 생성
        callback=audio_callback,                                 # 콜백
        channels=1,                                              # 1채널
        samplerate=SAMPLE_RATE,                                  # 샘플레이트
        blocksize=CHUNK_SIZE                                     # 블록 크기
    )
    audio_stream.start()                                         # 시작


# =========================================================
# [8. 시리얼 수신 스레드]
# =========================================================
def serial_reader_loop(on_status):                               # 시리얼 수신 루프
    global ser                                                   # 전역 시리얼
    while True:                                                  # 무한 루프
        if ser is None:                                          # 시리얼 없으면
            time.sleep(0.1)                                      # 대기
            continue                                             # 다음
        try:
            if ser.in_waiting:                                   # 수신 데이터 있으면
                msg = ser.readline().decode(errors='ignore').strip()  # 한 줄 읽기
                if "ON" in msg:                                  # ON이면
                    start_filling_local()                        # 로컬 시작
                    on_status("아두이노 ON 수신 → 주입 시작")      # 상태 표시
                elif "OFF" in msg:                               # OFF이면
                    stop_filling_local()                         # 로컬 종료
                    on_status("아두이노 OFF 수신 → 주입 종료")     # 상태 표시
        except Exception:
            pass
        time.sleep(0.01)                                         # CPU 과점유 방지


# =========================================================
# [9. customtkinter GUI (가로 레이아웃)]
# =========================================================
def run_kiosk_gui():
    ctk.set_appearance_mode("light")                             # 라이트 모드
    ctk.set_default_color_theme("blue")                          # 기본 테마

    C_BG = "#F6F7FB"                                             # 전체 배경
    C_CARD = "#FFFFFF"                                           # 카드
    C_NAVY = "#0B2D5B"                                           # 네이비 포인트
    C_NAVY_HOVER = "#123A73"                                     # 네이비 hover
    C_TEXT = "#0F172A"                                           # 텍스트
    C_MUTED = "#64748B"                                          # 보조 텍스트

    app = ctk.CTk()                                              # 메인 창
    app.title("주파수 기반 급수 제어 시스템")                      # 타이틀
    app.configure(fg_color=C_BG)                                 # 배경

    # ===== 창 크기 + 위치 고정 =====
    app.update_idletasks()                                       # OS 배치 전 내부 계산 갱신
    if USE_CENTER:                                               # 중앙이면
        sw = app.winfo_screenwidth()                             # 화면 가로
        sh = app.winfo_screenheight()                            # 화면 세로
        x = max(0, (sw - WIN_W) // 2)                            # 중앙 x
        y = max(0, (sh - WIN_H) // 2)                            # 중앙 y
        app.geometry(f"{WIN_W}x{WIN_H}+{x}+{y}")                  # 적용
    else:                                                        # 고정이면
        app.geometry(f"{WIN_W}x{WIN_H}+{WIN_X}+{WIN_Y}")          # 적용
    app.minsize(WIN_W, WIN_H)                                    # 최소 크기

    # ===== 상태 변수 =====
    status_var = ctk.StringVar(value="초기화 중...")              # 상태바
    port_var = ctk.StringVar(value=PORT)                         # 포트
    baud_var = ctk.StringVar(value=str(BAUD_RATE))               # baud

    d_var = ctk.StringVar(value="지름(D) : - cm")                # 지름
    f_var = ctk.StringVar(value="주파수(F) : - Hz")              # 주파수
    tf_var = ctk.StringVar(value="목표(Target) : - Hz")          # 목표
    air_var = ctk.StringVar(value="공기층(Air) : - cm")          # 공기층
    hit_var = ctk.StringVar(value=f"확신(Hits) : 0/{STOP_TRIGGER_COUNT}")  # 확신

    def set_status(s: str):
        status_var.set(s)                                        # 상태텍스트 변경
        print(f"\n[GUI] {s}")                                    # 터미널 출력

    def do_connect():
        global PORT, BAUD_RATE                                   # 전역 업데이트
        PORT = port_entry.get().strip()                          # 입력 포트
        try:
            BAUD_RATE = int(baud_entry.get().strip())            # 입력 baud
        except Exception:
            BAUD_RATE = 9600                                     # 기본값
        ok = connect_serial(PORT, BAUD_RATE)                     # 연결 시도
        set_status("아두이노 연결 성공" if ok else "아두이노 연결 실패(테스트 모드)")  # 상태
        ensure_audio_stream()                                    # 스트림 시작
        print("\n[준비] 아두이노 ON/OFF 대기중...")
        print(f"[설정] 유량: {FLOW_RATE} mL/s | 동적 보정 모드")

    def gui_on():
        serial_write(b'1')                                       # 아두이노 ON
        start_filling_local()                                    # 로컬 시작
        set_status("GUI ON → 주입 시작")                          # 상태 표시

    def gui_off():
        serial_write(b'0')                                       # 아두이노 OFF
        stop_filling_local()                                     # 로컬 종료
        set_status("GUI OFF → 주입 종료")                         # 상태 표시

    def on_close():
        serial_write(b'0')                                       # 닫기 시 OFF
        try:
            if ser is not None:
                ser.close()                                      # 시리얼 닫기
        except Exception:
            pass
        try:
            if audio_stream is not None:
                audio_stream.stop()                              # 오디오 정지
                audio_stream.close()                             # 오디오 닫기
        except Exception:
            pass
        app.destroy()                                            # 창 종료

    # =====================================================
    # 가로(2열) 레이아웃
    # =====================================================
    container = ctk.CTkFrame(app, fg_color=C_BG, corner_radius=0)
    container.pack(fill="both", expand=True, padx=20, pady=20)

    card = ctk.CTkFrame(container, fg_color=C_CARD, corner_radius=20)
    card.pack(fill="both", expand=True)

    card.grid_rowconfigure(0, weight=0)                          # header
    card.grid_rowconfigure(1, weight=1)                          # body
    card.grid_rowconfigure(2, weight=0)                          # footer
    card.grid_columnconfigure(0, weight=1)

    # ===== 헤더(상단 전체 폭) =====
    header = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=20)
    header.grid(row=0, column=0, sticky="ew", padx=24, pady=(24, 10))
    header.grid_columnconfigure(0, weight=1)

    title = ctk.CTkLabel(
        header, text="주파수 기반 급수 제어 시스템", text_color=C_NAVY,
        font=ctk.CTkFont(family="Malgun Gothic", size=28, weight="bold")
    )
    title.grid(row=0, column=0, sticky="w")

    subtitle = ctk.CTkLabel(
        header, text="ON/OFF + 실시간 추정값 + 실시간 그래프",
        text_color=C_MUTED,
        font=ctk.CTkFont(family="Malgun Gothic", size=13, weight="normal")
    )
    subtitle.grid(row=1, column=0, sticky="w", pady=(6, 0))

    # 로고(헤더 오른쪽 상단)
    try:
        pil_img = Image.open(LOGO_PATH)
        logo_img = ctk.CTkImage(light_image=pil_img, size=LOGO_SIZE)
        app.logo_img = logo_img
        logo_label = ctk.CTkLabel(header, text="", image=logo_img, fg_color="transparent")
        logo_label.place(relx=1.0, rely=0.0, anchor="ne")
    except Exception as e:
        print(f"\n[로고] 로드 실패: {e}")

    # ===== 본문(2열) =====
    body = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=16)
    body.grid(row=1, column=0, sticky="nsew", padx=24, pady=(0, 10))
    body.grid_rowconfigure(0, weight=1)
    body.grid_columnconfigure(0, weight=1)                       # left
    body.grid_columnconfigure(1, weight=1)                       # right

    left = ctk.CTkFrame(body, fg_color=C_CARD, corner_radius=16)
    left.grid(row=0, column=0, sticky="nsew", padx=(0, 12))

    right = ctk.CTkFrame(body, fg_color=C_CARD, corner_radius=16)
    right.grid(row=0, column=1, sticky="nsew", padx=(12, 0))

    # -------------------------
    # LEFT: 연결 + 버튼
    # -------------------------
    conn = ctk.CTkFrame(left, fg_color=C_CARD, corner_radius=16)
    conn.pack(fill="x", pady=(0, 12))

    conn.grid_columnconfigure(0, weight=0)
    conn.grid_columnconfigure(1, weight=1)
    conn.grid_columnconfigure(2, weight=0)
    conn.grid_columnconfigure(3, weight=1)

    ctk.CTkLabel(
        conn, text="포트(PORT)", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=14, weight="bold")
    ).grid(row=0, column=0, sticky="w", padx=(0, 12), pady=(0, 10))

    port_entry = ctk.CTkEntry(
        conn, textvariable=port_var, height=40,
        fg_color="#F1F5F9", border_color="#E2E8F0", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=14)
    )
    port_entry.grid(row=0, column=1, sticky="ew", pady=(0, 10))

    ctk.CTkLabel(
        conn, text="보드레이트(BAUD)", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=14, weight="bold")
    ).grid(row=0, column=2, sticky="w", padx=(18, 12), pady=(0, 10))

    baud_entry = ctk.CTkEntry(
        conn, textvariable=baud_var, height=40,
        fg_color="#F1F5F9", border_color="#E2E8F0", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=14)
    )
    baud_entry.grid(row=0, column=3, sticky="ew", pady=(0, 10))

    connect_btn = ctk.CTkButton(
        conn, text="연결", height=44,
        fg_color=C_CARD, hover_color="#EEF2FF",
        border_color="#CBD5E1", border_width=2,
        text_color=C_NAVY,
        font=ctk.CTkFont(family="Malgun Gothic", size=16, weight="bold"),
        command=do_connect
    )
    connect_btn.grid(row=1, column=0, columnspan=4, sticky="ew")

    btn_area = ctk.CTkFrame(left, fg_color=C_CARD, corner_radius=16)
    btn_area.pack(fill="x", pady=(0, 12))

    on_btn = ctk.CTkButton(
        btn_area, text="ON  (주입 시작)", height=64,
        fg_color=C_NAVY, hover_color=C_NAVY_HOVER,
        text_color="white",
        font=ctk.CTkFont(family="Malgun Gothic", size=20, weight="bold"),
        corner_radius=18,
        command=gui_on
    )
    on_btn.pack(fill="x", pady=(0, 10))

    off_btn = ctk.CTkButton(
        btn_area, text="OFF (주입 종료)", height=64,
        fg_color=C_CARD, hover_color="#F1F5F9",
        border_color="#CBD5E1", border_width=2,
        text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=20, weight="bold"),
        corner_radius=18,
        command=gui_off
    )
    off_btn.pack(fill="x")

    # -------------------------
    # RIGHT: 진행바 + 값 + 그래프
    # -------------------------
    progress_area = ctk.CTkFrame(right, fg_color=C_CARD, corner_radius=16)
    progress_area.pack(fill="x", pady=(0, 12))

    progress_title = ctk.CTkLabel(
        progress_area, text="정지 확신도", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=16, weight="bold")
    )
    progress_title.pack(anchor="w", pady=(0, 8))

    progress = ctk.CTkProgressBar(
        progress_area, height=18, corner_radius=10,
        fg_color="#E5E7EB", progress_color=C_NAVY
    )
    progress.set(0.0)
    progress.pack(fill="x")

    stats = ctk.CTkFrame(right, fg_color=C_CARD, corner_radius=16)
    stats.pack(fill="x", pady=(0, 12))

    def make_stat_row(parent, var):
        row = ctk.CTkFrame(parent, fg_color=C_CARD, corner_radius=12)
        row.pack(fill="x", pady=4)
        lbl = ctk.CTkLabel(
            row, textvariable=var, text_color=C_TEXT,
            font=ctk.CTkFont(family="Malgun Gothic", size=16, weight="bold")
        )
        lbl.pack(anchor="w", padx=6)
        return row

    make_stat_row(stats, d_var)
    make_stat_row(stats, f_var)
    make_stat_row(stats, tf_var)
    make_stat_row(stats, air_var)
    make_stat_row(stats, hit_var)

    plot_frame = ctk.CTkFrame(right, fg_color=C_CARD, corner_radius=16)
    plot_frame.pack(fill="both", expand=True)

    plot_title = ctk.CTkLabel(
        plot_frame, text="실시간 주파수 추적 그래프", text_color=C_TEXT,
        font=ctk.CTkFont(family="Malgun Gothic", size=16, weight="bold")
    )
    plot_title.pack(anchor="w", pady=(0, 6))

    fig = Figure(figsize=(6.2, 3.0), dpi=100)
    ax = fig.add_subplot(111)
    ax.set_xlabel("t [s]")
    ax.set_ylabel("f [Hz]")
    ax.grid(True, alpha=0.3)
    fig.tight_layout(pad=3.0)

    line_freq, = ax.plot([], [], linewidth=1.5)
    target_line = ax.axhline(y=0, linestyle="--", alpha=0.8)

    canvas = FigureCanvasTkAgg(fig, master=plot_frame)
    canvas_widget = canvas.get_tk_widget()
    canvas_widget.pack(fill="both", expand=True)

    def update_plot():
        with lock:
            t_list = list(history_time)
            f_list = list(history_freq)
            tf = float(target_freq)

        if len(t_list) == 0:
            line_freq.set_data([], [])
            target_line.set_ydata([0, 0])
            ax.set_xlim(0, 1)
            ax.set_ylim(FREQ_MIN_LIMIT, FREQ_MAX_LIMIT)
            canvas.draw_idle()
            return

        if len(t_list) > PLOT_MAX_POINTS:
            t_list = t_list[-PLOT_MAX_POINTS:]
            f_list = f_list[-PLOT_MAX_POINTS:]

        line_freq.set_data(t_list, f_list)

        t_max = max(t_list)
        ax.set_xlim(max(0, t_max - 30), max(5, t_max))

        f_min = min(f_list)
        f_max = max(f_list)
        pad = max(50, 0.1 * (f_max - f_min))
        ax.set_ylim(max(0, f_min - pad), f_max + pad)

        if tf > 0:
            target_line.set_ydata([tf, tf])
            target_line.set_alpha(0.9)
        else:
            target_line.set_ydata([0, 0])
            target_line.set_alpha(0.0)

        canvas.draw_idle()

    # ===== 하단 상태바(전체 폭) =====
    footer = ctk.CTkFrame(card, fg_color=C_CARD, corner_radius=20)
    footer.grid(row=2, column=0, sticky="ew", padx=24, pady=(0, 18))

    status_lbl = ctk.CTkLabel(
        footer, textvariable=status_var, text_color=C_MUTED,
        font=ctk.CTkFont(family="Malgun Gothic", size=14, weight="normal")
    )
    status_lbl.pack(anchor="w")

    def periodic_update():
        with lock:
            d = current_diameter
            sf = last_stable_f
            tf = target_freq
            air = last_current_air
            hits = consecutive_stop_hits

        d_var.set(f"지름(D) : {d:.2f} cm" if d > 0 else "지름(D) : - cm")
        f_var.set(f"주파수(F) : {sf:.0f} Hz" if sf > 0 else "주파수(F) : - Hz")
        tf_var.set(f"목표(Target) : {tf:.0f} Hz" if tf > 0 else "목표(Target) : - Hz")
        air_var.set(f"공기층(Air) : {air:.2f} cm" if air != 0 else "공기층(Air) : - cm")
        hit_var.set(f"확신(Hits) : {hits}/{STOP_TRIGGER_COUNT}")

        progress.set(hits / float(STOP_TRIGGER_COUNT))

        update_plot()
        app.after(PLOT_UPDATE_MS, periodic_update)

    app.protocol("WM_DELETE_WINDOW", on_close)
    app.bind("<Escape>", lambda e: on_close())

    do_connect()
    ensure_audio_stream()

    t = threading.Thread(target=serial_reader_loop, args=(set_status,), daemon=True)
    t.start()

    periodic_update()
    app.mainloop()


# =========================================================
# [10. 엔트리포인트]
# =========================================================
if __name__ == "__main__":
    run_kiosk_gui()
